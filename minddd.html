<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Horizontal Mindmap — Array & String Algorithms</title>

  <!-- ✅ Include D3.js -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
S
  <!-- ✅ Tailwind CDN for styling (optional) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f9fafb;
      margin: 0;
      overflow: hidden;
    }
    svg {
      width: 100%;
      height: 100vh;
    }
    .node text {
      fill: white;
      font-size: 14px;
    }
    .link {
      fill: none;
      stroke: #cbd5e1;
      stroke-width: 1.5px;
    }
  </style>
</head>
<body>
  <div class="w-full h-screen bg-white rounded-md shadow p-4 overflow-hidden">
    <div class="flex items-center justify-between mb-2">
      <h3 class="text-lg font-semibold">
        Horizontal Mindmap (Array & String Algorithms)
      </h3>
      <div class="text-sm text-gray-500">Click nodes to expand / center</div>
    </div>
    <svg id="mindmap"></svg>
  </div>

  <script>
    const data = {
      name: "Array & String Algorithms Roadmap",
      children: [
        {
          name: "LEVEL 1 — Foundations",
          children: [
            {
              name: "Concepts to Learn",
              children: [
                { name: "Array basics" },
                { name: "String basics" },
                { name: "Big O complexity" },
              ],
            },
            {
              name: "Practice Problems",
              children: [
                { name: "Reverse an array/string" },
                { name: "Find min & max in array" },
                { name: "Count vowels/characters" },
                { name: "Check if palindrome" },
                { name: "Rotate array by k" },
              ],
            },
          ],
        },
        {
          name: "LEVEL 2 — Searching & Sorting",
          children: [
            {
              name: "Algorithms",
              children: [
                { name: "Linear Search" },
                { name: "Binary Search (Iterative/Recursive)" },
                { name: "Bubble / Selection / Insertion Sort" },
                { name: "Merge Sort" },
                { name: "Quick Sort" },
                { name: "Counting / Radix / Bucket Sort" },
              ],
            },
            {
              name: "Binary Search Variants",
              children: [
                { name: "Find first/last occurrence" },
                { name: "Search in rotated array" },
                { name: "Find peak element" },
              ],
            },
          ],
        },
        {
          name: "LEVEL 3 — Subarray & Subsequence Patterns",
          children: [
            {
              name: "Techniques",
              children: [
                { name: "Two Pointer Technique" },
                { name: "Sliding Window" },
                { name: "Prefix Sum" },
                { name: "Kadane’s Algorithm" },
              ],
            },
            {
              name: "Practice Problems",
              children: [
                { name: "Maximum subarray sum" },
                { name: "Longest subarray with given sum" },
                { name: "Move zeroes to end" },
                { name: "Pair sum (Two Sum / 3Sum)" },
                { name: "Longest substring without repeating chars" },
              ],
            },
          ],
        },
      ],
    };

    const svg = d3.select("#mindmap");
    const width = window.innerWidth;
    const height = window.innerHeight;
    const margin = { top: 50, right: 120, bottom: 50, left: 100 };

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
    const colorScale = ["#3b82f6", "#10b981", "#f59e0b", "#ef4444"];

    const root = d3.hierarchy(data);
    root.x0 = 0;
    root.y0 = 0;

    const treeLayout = d3.tree().nodeSize([100, 300]);
    const zoom = d3.zoom().scaleExtent([0.3, 2.5]).on("zoom", (event) => g.attr("transform", event.transform));
    svg.call(zoom);

    if (root.children) root.children.forEach(collapse);
    update(root);
    centerInitialNode(root);

    function collapse(d) {
      if (d.children) {
        d._children = d.children;
        d._children.forEach(collapse);
        d.children = null;
      }
    }

    function update(source) {
      const tree = treeLayout(root);
      const nodes = tree.descendants();
      const links = tree.links();
      nodes.forEach((d) => (d.y = d.depth * 250));

      const node = g.selectAll("g.node").data(nodes, (d) => d.id || (d.id = ++window.i || 1));

      const nodeEnter = node
        .enter()
        .append("g")
        .attr("class", "node cursor-pointer")
        .attr("transform", (d) => `translate(${source.y0 || source.y},${source.x0 || source.x})`)
        .on("click", (event, d) => {
          if (d.children) {
            d._children = d.children;
            d.children = null;
          } else if (d._children) {
            d.children = d._children;
            d._children = null;
          }
          update(d);
          if (d.children || d._children) centerNode(d);
        });

      const texts = nodeEnter
        .append("text")
        .attr("dy", 4)
        .attr("text-anchor", "middle")
        .style("fill", "white")
        .style("font-size", "14px")
        .text((d) => d.data.name);

      nodeEnter.each(function (d) {
        const textNode = d3.select(this).select("text").node();
        const bbox = textNode.getBBox();
        const paddingX = 15,
          paddingY = 10;
        d3.select(this)
          .insert("rect", "text")
          .attr("x", -bbox.width / 2 - paddingX)
          .attr("y", -bbox.height / 2 - paddingY / 2)
          .attr("width", bbox.width + paddingX * 2)
          .attr("height", bbox.height + paddingY)
          .attr("rx", 6)
          .attr("ry", 6)
          .style("fill", (d) => colorScale[d.depth % colorScale.length])
          .style("stroke", "#1e293b")
          .style("stroke-width", 1.5);
      });

      nodeEnter
        .merge(node)
        .transition()
        .duration(400)
        .attr("transform", (d) => `translate(${d.y},${d.x})`);

      node.exit().transition().duration(300).attr("transform", (d) => `translate(${source.y},${source.x})`).remove();

      const link = g.selectAll("path.link").data(links, (d) => d.target.id);

      link
        .enter()
        .insert("path", "g")
        .attr("class", "link")
        .attr("d", (d) => {
          const o = { x: source.x0 || source.x, y: source.y0 || source.y };
          return diagonal({ source: o, target: o });
        })
        .merge(link)
        .transition()
        .duration(400)
        .attr("d", diagonal);

      link
        .exit()
        .transition()
        .duration(300)
        .attr("d", (d) => {
          const o = { x: source.x, y: source.y };
          return diagonal({ source: o, target: o });
        })
        .remove();

      nodes.forEach((d) => {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    }

    function diagonal(d) {
      return `M${d.source.y},${d.source.x}
              C${(d.source.y + d.target.y) / 2},${d.source.x}
               ${(d.source.y + d.target.y) / 2},${d.target.x}
               ${d.target.y},${d.target.x}`;
    }

    // Center node smoothly in the middle of the screen
function centerNode(source) {
  const transform = d3.zoomTransform(svg.node());
  const x = source.x;
  const y = source.y;
  const scale = transform.k;

  const centerX = width / 2;
  const centerY = height / 2;

  const translateX = centerX - y * scale;
  const translateY = centerY - x * scale;

  svg.transition()
    .duration(600)
    .call(zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(scale));
}

// Center the root node on initial render
function centerInitialNode(source) {
  const initialScale = 1; // You can tweak this if you want initial zoom-out
  const x = source.x0 || 0;
  const y = source.y0 || 0;

  const centerX = width / 2;
  const centerY = height / 2;

  const translateX = centerX - y * initialScale;
  const translateY = centerY - x * initialScale;

  svg.call(
    zoom.transform,
    d3.zoomIdentity.translate(translateX, translateY).scale(initialScale)
  );
}


  </script>
</body>
</html>
